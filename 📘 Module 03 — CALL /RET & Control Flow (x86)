# Module 03 â€” CALL / RET & Control Flow (x86)

## ğŸ¯ Objectives
By the end of this module, you should be able to:
- Understand how CALL and RET manage program flow
- Know how functions are invoked at assembly level
- Trace return addresses on the stack
- Identify function boundaries in IDA and x32dbg
- Understand how EIP changes during CALL and RET

---

# ğŸ§  1. What happens during a CALL?

A `call` instruction does **two things**:

### âœ” 1) Push the return address  
This is the address of the instruction *after* the CALL.

### âœ” 2) Jump to the target function  
The CPU sets **EIP** = function address.

### Example:
```asm
call my_function
Internally:

perl
Copy code
push return_address
jmp my_function
This is why every function has access to its return address at:

csharp
Copy code
[ebp+4]
ğŸ§© 2. Function Return Value (EAX)
The return value of a function is placed in EAX.

Example:

asm
Copy code
mov eax, 5
ret
In C:

c
Copy code
return 5;
EAX = function result
RET = send result back to caller.

ğŸ›‘ 3. The RET Instruction
RET performs:

perl
Copy code
pop eip
Meaning:

It pops the saved return address from the stack

Then sets EIP = that address

Execution continues where the CALL originated

Example:
Caller:

asm
Copy code
call add_numbers
mov ecx, eax
Callee:

asm
Copy code
add_numbers:
    mov eax, 10
    ret
Logic:

CALL pushes next instruction address

add_numbers sets EAX

RET loads EIP with saved return address

Execution continues at: mov ecx, eax

ğŸ”¢ 4. RET N (Stack Cleanup)
ret n means:

csharp
Copy code
ret n  â†’  ret + add esp, n
Used to remove arguments from the stack after a function call in stdcall calling convention.

Example:

asm
Copy code
ret 8
Equivalent to:

asm
Copy code
ret
add esp, 8
ğŸ”„ 5. Control Flow in Assembly
Control flow is determined by:

âœ” CALL
Enter a function

âœ” RET
Return to caller

âœ” Conditional jumps
JE / JNE / JG / JL / JZ / JNZ

âœ” Unconditional jumps
JMP

âœ” Loops
LOOP, JNZ, DEC + JNZ, etc.

ğŸ” 6. CALL Graph in IDA
IDA creates a call graph showing:

which functions call others

entry points

function boundaries

return flow

Press:

sql
Copy code
F4 â†’ Function calls window  
Space â†’ Graph View  
ğŸ§ª 7. Real Example Breakdown
Caller:
asm
Copy code
push 5
push 3
call add
add esp, 8
mov ebx, eax
Callee:
asm
Copy code
add:
    mov eax, [ebp+8]   ; first argument
    add eax, [ebp+0xC] ; second argument
    ret
Flow:

Caller pushes args

CALL â†’ pushes return address

Function computes result

RET â†’ jumps back

Caller reads EAX result

ğŸ§­ 8. CALL-RET Flow in Debugger (x32dbg)
To trace a CALL:
Set a breakpoint before CALL

Press F7 (Step Into) â†’ enters function

Inside function, press F8 (Step Over instructions)

RET will return to the caller

EIP jumps back automatically

ğŸ“Œ 9. Quick Notes Summary
CALL automatically pushes return address

RET pops return address

EAX always holds function return value

ret n cleans arguments from the stack

CALL and RET control most high-level function flow

IDA graph view shows function call relationships

Debuggers show real-time EIP flow through CALL/RET

ğŸ¯ 10. Exercises
âœ” Q1: What two things does CALL do?
âœ” Q2: Where is the return address stored in the callee?
âœ” Q3: What does RET do to EIP?
âœ” Q4: Explain the difference between ret and ret 8.
âœ” Q5: Why is EAX important after a RET?
âœ” Q6: Trace a simple CALL/RET flow in x32dbg.
