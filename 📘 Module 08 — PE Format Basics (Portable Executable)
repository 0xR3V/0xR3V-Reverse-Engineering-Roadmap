# Module 08 â€” PE Format Basics (Portable Executable)

## ğŸ¯ Objectives
By the end of this module, you should be able to:
- Understand the overall PE structure
- Locate the Optional Header and its key fields
- Distinguish between RVA and VA
- Identify the main sections (.text, .data, .rdata, .idata, .rsrc)
- Use CFF Explorer to navigate PE headers
- Understand where the Entry Point is located inside a PE file

---

# ğŸ§  1. What is a PE File?

A **Portable Executable (PE)** is the standard file format used by Windows for:
- `.exe`
- `.dll`
- `.sys` drivers
- `.ocx` components

It is a structured binary format loaded by the Windows Loader.

---

# ğŸ§© 2. High-Level PE Structure

A PE file contains the following major components:

+-------------------+
| DOS Header (MZ) |
+-------------------+
| DOS Stub |
+-------------------+
| PE Signature (PE00)|
+-------------------+
| File Header |
+-------------------+
| Optional Header |
+-------------------+
| Section Table |
+-------------------+
| Sections (.text, .data, ...) |
+-------------------+

yaml
Copy code

---

# ğŸ·ï¸ 3. DOS Header (MZ)

- First 64 bytes of the file  
- Identified by:  
4D 5A â†’ "MZ"

yaml
Copy code
- Only exists for backward compatibility with DOS  
- Not used much in modern reversing

---

# ğŸ“Œ 4. NT Headers

Contains two major parts:

### âœ” `File Header`  
Contains metadata:
- Machine type  
- Number of sections  
- Timestamp  
- Characteristics  

### âœ” `Optional Header` (MOST IMPORTANT PART)

Despite the name, it is **not optional** for PE files.

---

# ğŸ¯ 5. Optional Header â€” Critical Fields

These fields are used heavily in reverse engineering:

| Field | Description |
|--------|-------------|
| **ImageBase** | Default load address of module (e.g., `0x00400000`) |
| **AddressOfEntryPoint** | RVA of the programâ€™s first executed instruction |
| **SizeOfCode** | Size of `.text` section |
| **SizeOfImage** | Total size once loaded in memory |
| **Subsystem** | Console / GUI application |
| **DataDirectories** | Import table, export table, resources, etc. |

---

# ğŸ”¥ 6. RVA vs VA (Very Important)

### âœ” RVA  
Relative to ImageBase

Example:
AddressOfEntryPoint = 0x00016478 (RVA)

makefile
Copy code

### âœ” VA  
Actual memory address seen in the debugger  
Formula:

VA = ImageBase + RVA

shell
Copy code

### Example:
ImageBase = 0x00400000
AddressOfEntryPoint = 0x00016478

EntryPointVA = 0x00400000 + 0x00016478
= 0x00416478

yaml
Copy code

This is the address you enter inside:
- IDA (press **G**)
- x32dbg (Ctrl+G)

---

# ğŸ“¦ 7. Section Table (Section Headers)

After Optional Header, the Section Table begins.

Each section has:
- Name  
- VirtualAddress (RVA in memory)  
- VirtualSize  
- RawAddress (offset in file)  
- RawSize  
- Characteristics (R/W/X flags)

---

# ğŸ“‚ 8. The Most Important Sections

### ğŸ“Œ `.text`  
- Contains **code (assembly)**  
- Usually **R-X** (read + execute)  
- Entry Point (EP) lives here most of the time

---

### ğŸ“Œ `.rdata`  
- Contains strings, constants  
- Common place to find:
  - `"Correct!"`
  - `"Wrong!"`
  - `"Enter Serial:"`

---

### ğŸ“Œ `.data`  
- Modifiable global variables

---

### ğŸ“Œ `.idata`  
- Import Table (IAT)  
- Windows API functions imported by the program  
- Very important for malware analysis

---

### ğŸ“Œ `.rsrc`  
- Resources (icons, dialogs, bitmaps, version info)

---

# ğŸ¯ 9. Finding the Entry Point (EP)

Steps:

1. Open file in **CFF Explorer**  
2. Navigate to:  

NT Headers â†’ Optional Header

markdown
Copy code

3. Get:
- `ImageBase`
- `AddressOfEntryPoint`

4. Compute EP VA:

VA = ImageBase + AddressOfEntryPoint

yaml
Copy code

5. Jump to it in:
- IDA â†’ press **G**
- x32dbg â†’ Ctrl+G

---

# ğŸ› ï¸ 10. Matching EP to Its Section

To find which section contains the Entry Point:

For each section:
SectionStartVA = ImageBase + VirtualAddress
SectionEndVA = SectionStartVA + VirtualSize

makefile
Copy code

If:
SectionStartVA <= EntryPointVA <= SectionEndVA

yaml
Copy code

Then EP is inside that section.

Almost always `.text`.

---

# ğŸ” 11. Why This Module Matters

Understanding PE headers lets you:
- Find where code starts  
- Identify unpackers  
- Locate imports (WinAPI usage)  
- Distinguish code vs data  
- Move confidently inside IDA/x32dbg  
- Solve crackmes and malware samples faster  

This is the foundation before learning Import Table (next module).

---

# âš¡ 12. Quick Notes Summary

- PE files contain structured metadata  
- Optional Header = most useful part  
- EntryPoint = programâ€™s starting instruction  
- RVA is NOT a real address  
- VA = ImageBase + RVA  
- `.text` = code section  
- `.rdata` = strings & constants  
- `.idata` = import table  
- `.rsrc` = resources  
- Section Table maps file â†’ memory  

---

# ğŸ§ª 13. Exercises

âœ” **Q1:** What is the difference between RVA and VA?  
âœ” **Q2:** Where is AddressOfEntryPoint located?  
âœ” **Q3:** Why is the Entry Point usually in `.text`?  
âœ” **Q4:** Convert the following:  

ImageBase: `0x00400000`  
RVA: `0x00011050`  

Find VA.

âœ” **Q5:** What is stored in the `.rdata` section?

---

## âœ… End of Module 08  
