ğŸ¯ Objectives

By the end of this module, you will be able to:

Understand how Windows executables import external functions (APIs).

Identify which DLLs and functions a program uses.

Use CFF Explorer, IDA, and x32dbg to read the Import Table.

Trace API calls inside disassembly.

Guess program behavior without running it based on its imports.

Follow IAT entries and cross-references to reach important code paths.

ğŸ§  1. What Is the Import Table?

An executable does not contain the code of Windows API functions inside it.
Instead, it contains:

DLL name (e.g., KERNEL32.dll, USER32.dll)

Function name (e.g., MessageBoxA, CreateFileA)

RVA to the import list

A runtime popuÂ­lated table: IAT â€” Import Address Table

âœ” Import Table = The static description
âœ” IAT = The runtime table containing real function addresses
ğŸ§  2. Why Is IAT Important in Reverse Engineering?

Because you can often figure out:

Does the program show GUI? â†’ MessageBoxA, DialogBoxParamA

Does it work with files? â†’ CreateFileA, ReadFile, WriteFile

Does it connect to the Internet? â†’ WinHttp*, InternetOpenA

Does it manipulate processes? â†’ CreateProcessA, OpenProcess

Does it check serial keys? â†’ strcmp, strncmp, GetDlgItemTextA

You can understand the program without executing it.

ğŸ§ª 3. Reading the Import Table in CFF Explorer

Open the EXE

Go to:
Data Directories â†’ Import Directory

You will see:

KERNEL32.dll
    CreateFileA
    ReadFile
    lstrcmpA
USER32.dll
    MessageBoxA
MSVCRT.dll
    printf


Each DLL expands into its imported functions.

ğŸ§  4. IAT Inside IDA

In IDA:

Open:
View â†’ Open Subviews â†’ Imports

IDA will show:

KERNEL32.dll
   ! CreateFileA
   ! GetModuleHandleA
USER32.dll
   ! MessageBoxA
MSVCRT.dll
   ! strcmp


Double-click any function â†’ IDA jumps to IAT entry.

Press X to view Xrefs â†’ you will see where the program calls that API.

This is usually how we find:

Validation code

Registration screens

File operations

Malware behaviors

ğŸ§  5. IAT in x32dbg

Inside x32dbg:

Load the program.

Go to Imports tab.

You will see all imported functions.

Double-click an entry â†’ jump to its IAT address.

Find all call dword ptr [IAT_Function].

This is the runtime equivalent of IDAâ€™s Xrefs.

ğŸ§© 6. How Import Resolution Works (Short Version)

At load time:

Windows loads required DLLs.

For each imported function, Windows resolves its address using GetProcAddress.

Windows writes the resolved address into the IAT.

The program calls functions indirectly via call [IAT].

ğŸ§  7. IAT vs INT (Import Name Table)
Table	Meaning	Used for
INT	Function names	For loader to find functions
IAT	Actual addresses	What the program calls

For reverse engineering, the IAT is what matters.

ğŸ” 8. Recognizing API Calls in Disassembly

Typical IAT call:

call ds:MessageBoxA


or:

call dword ptr ds:[0x404000]


If the address belongs to .idata section â†’ it's an API call.

ğŸ§  9. Why CrackMes rely on IAT

Because you can quickly find:

Validation functions

GUI prompts (â€œCorrect!â€, â€œWrong serial!â€)

Interactions with user input

Most serial-checking CrackMes call:

GetDlgItemTextA
strcmp
MessageBoxA


So you just follow the Xrefs from these APIs â†’ reach the validation logic.

ğŸ§ª 10. Practical Exercise
Exercise A â€” Read Imports

Using CFF Explorer:

List all DLLs imported.

Under each DLL, list at least 3 functions.

Exercise B â€” IDA Xrefs

Open the EXE in IDA.

Go to Imports.

Find MessageBoxA, strcmp, or GetDlgItemTextA.

Press X and follow the call location.

Identify where success/fail messages appear.

Exercise C â€” x32dbg

Load program.

Go to Imports tab.

Double-click on some imported API.

Break when the call executes.

ğŸ“ Summary

Import Table describes what functions the program wants.

IAT is the actual addresses patched at runtime.

IDAâ€™s Imports view + Xrefs = fastest way to reach important logic.

CrackMes heavily rely on a small set of APIs â†’ easy to detect.

Debuggers allow tracking the moment an API is called.


