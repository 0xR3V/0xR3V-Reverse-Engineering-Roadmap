ğŸ” Overview

Windows executables do not contain the code of Windows API functions.
Instead, they reference external DLLs such as:

KERNEL32.dll

USER32.dll

MSVCRT.dll

Understanding these imports allows a reverse engineer to:

Predict program behavior without executing it

Identify GUI, file, registry, or network operations

Locate serial validation logic in CrackMes

Analyze malware capabilities

Follow API calls directly to critical parts of the code

ğŸ§  What Is the Import Table?

Each executable contains:

List of DLLs it depends on

List of functions imported from each DLL

RVAs of import structures

IAT (Import Address Table) entries that get filled at runtime

âœ” Import Table = Static description
âœ” IAT = Runtime table with real addresses
ğŸ§  Reading the Import Directory in CFF Explorer

CFF Explorer clearly shows:

DLL names

Number of imported functions

IAT and INT addresses

List of APIs under each DLL

ğŸ“¸ Screenshot â€” Import Directory (CFF Explorer):

From the screenshot:

USER32.dll â†’ 9 functions

KERNEL32.dll â†’ 63 functions

This tells us the program uses:

GUI APIs (USER32)

System-level APIs (KERNEL32)

ğŸ§  Understanding USER32.dll Imports

USER32.dll contains typical GUI-related APIs such as:

Function	Meaning
MessageBoxA	Shows a popup message
GetDlgItemTextA	Reads text from an input field
CreateDialogParamA	Creates a dialog window
PostQuitMessage	Ends the message loop
ShowWindow	Displays a window

These functions indicate the EXE is GUI-based and interacts with the user.

ğŸ§  Viewing API Usage in IDA (Xrefs)

IDA provides an Imports view showing all DLLs and imported functions.
More importantly, you can check:

âœ” Where each API is used

(Using Xrefs â€” Cross References)

Example:
When you check MessageBoxA references, IDA shows all code locations calling it.

ğŸ“¸ Screenshot â€” Xrefs to MessageBoxA:

This reveals:

Success message block (â€œCongrats!â€)

Failure message block (â€œWrong serialâ€)

Validation logic leading to those blocks

ğŸ§  Why This Is Important?

Because these Xrefs often lead directly to:

The serial checking function

The main validation loop

Error and success dialogs

Program's core functionality

IAT + Xrefs = super fast navigation to the important logic.

ğŸ§© How IAT Works Internally

At runtime:

Windows loads DLLs

For each imported function:

Uses GetProcAddress to find its address

Writes the address into the IAT

The program later calls functions using:

call dword ptr ds:[IAT_Function]


If the call operand is inside .idata, itâ€™s an API call.

ğŸ§ª Exercises (Required)
Exercise A â€” CFF Explorer

List all DLLs imported by the EXE and predict:

Is it GUI?

Does it read user input?

Does it compare strings?

Does it interact with files or registry?

Exercise B â€” IDA Xrefs

In IDA:

Open Imports window

Click MessageBoxA, then press X

Document the following:

Success message block

Failure message block

Condition between them (cmp / test)

Exercise C â€” x32dbg

In x32dbg:

Load the program

Open Imports tab

Double click an API (like MessageBoxA)

Set a breakpoint

Run the program and observe when the API is called

ğŸ“ Summary

Import Table reveals program behavior without execution

IAT contains real addresses of APIs at runtime

IDA Xrefs quickly lead you to validation functions in CrackMes

USER32/Kernel32 imports tell you what the program does

Understanding imports is essential for malware analysis and RE
